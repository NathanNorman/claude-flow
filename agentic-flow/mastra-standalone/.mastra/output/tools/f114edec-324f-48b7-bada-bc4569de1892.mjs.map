{"version":3,"file":"f114edec-324f-48b7-bada-bc4569de1892.mjs","sources":["../../../src/mastra/tools/learning-memory-tools.js"],"sourcesContent":["import { createTool } from '@mastra/core';\nimport { z } from 'zod';\n\n// Memory storage simulation\nconst memoryStore = new Map();\nconst knowledgeGraphStore = new Map();\nconst backupStore = new Map();\nconst contextStore = new Map();\nconst learningStore = new Map();\n\n// Utility functions\nconst generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\nconst isExpired = (expiresAt) => {\n  return expiresAt && new Date(expiresAt) < new Date();\n};\n\nconst cleanExpiredMemories = (namespace) => {\n  const memories = memoryStore.get(namespace) || new Map();\n  for (const [key, value] of memories.entries()) {\n    if (isExpired(value.expiresAt)) {\n      memories.delete(key);\n    }\n  }\n};\n\n// Tool 1: Memory Store\nexport const memoryStoreTool = createTool({\n  id: 'memory-store',\n  name: 'Memory Store',\n  description: 'Store persistent memory with TTL and namespacing',\n  version: '1.0.0',\n  inputSchema: z.object({\n    namespace: z.string().default('default'),\n    key: z.string(),\n    value: z.any(),\n    ttl: z.number().optional().describe('Time to live in seconds'),\n    tags: z.array(z.string()).optional(),\n    metadata: z.record(z.any()).optional()\n  }),\n  execute: async ({ namespace, key, value, ttl, tags, metadata }) => {\n    if (!memoryStore.has(namespace)) {\n      memoryStore.set(namespace, new Map());\n    }\n    \n    const memories = memoryStore.get(namespace);\n    const expiresAt = ttl ? new Date(Date.now() + ttl * 1000).toISOString() : null;\n    \n    const memory = {\n      key,\n      value,\n      namespace,\n      createdAt: new Date().toISOString(),\n      expiresAt,\n      tags: tags || [],\n      metadata: metadata || {},\n      accessCount: 0,\n      lastAccessed: new Date().toISOString()\n    };\n    \n    memories.set(key, memory);\n    \n    return {\n      success: true,\n      memory: {\n        key,\n        namespace,\n        expiresAt,\n        tags: memory.tags\n      }\n    };\n  }\n});\n\n// Tool 2: Memory Retrieve\nexport const memoryRetrieveTool = createTool({\n  id: 'memory-retrieve',\n  name: 'Memory Retrieve',\n  description: 'Retrieve memories with pattern matching',\n  version: '1.0.0',\n  inputSchema: z.object({\n    namespace: z.string().default('default'),\n    key: z.string().optional(),\n    pattern: z.string().optional(),\n    includeExpired: z.boolean().default(false)\n  }),\n  execute: async ({ namespace, key, pattern, includeExpired }) => {\n    if (!memoryStore.has(namespace)) {\n      return { success: false, error: 'Namespace not found' };\n    }\n    \n    const memories = memoryStore.get(namespace);\n    cleanExpiredMemories(namespace);\n    \n    if (key) {\n      const memory = memories.get(key);\n      if (!memory) {\n        return { success: false, error: 'Memory not found' };\n      }\n      \n      if (!includeExpired && isExpired(memory.expiresAt)) {\n        return { success: false, error: 'Memory expired' };\n      }\n      \n      // Update access info\n      memory.accessCount++;\n      memory.lastAccessed = new Date().toISOString();\n      \n      return { success: true, memory };\n    }\n    \n    // Pattern matching\n    const results = [];\n    const regex = pattern ? new RegExp(pattern, 'i') : null;\n    \n    for (const [k, memory] of memories.entries()) {\n      if (!includeExpired && isExpired(memory.expiresAt)) continue;\n      \n      if (!regex || regex.test(k) || regex.test(JSON.stringify(memory.value))) {\n        memory.accessCount++;\n        memory.lastAccessed = new Date().toISOString();\n        results.push(memory);\n      }\n    }\n    \n    return { success: true, memories: results };\n  }\n});\n\n// Tool 3: Memory Search\nexport const memorySearchTool = createTool({\n  id: 'memory-search',\n  name: 'Memory Search',\n  description: 'Advanced memory search with filters',\n  version: '1.0.0',\n  inputSchema: z.object({\n    namespace: z.string().optional(),\n    query: z.string(),\n    filters: z.object({\n      tags: z.array(z.string()).optional(),\n      createdAfter: z.string().optional(),\n      createdBefore: z.string().optional(),\n      minAccessCount: z.number().optional()\n    }).optional(),\n    limit: z.number().default(10)\n  }),\n  execute: async ({ namespace, query, filters = {}, limit }) => {\n    const results = [];\n    const namespaces = namespace ? [namespace] : Array.from(memoryStore.keys());\n    const queryRegex = new RegExp(query, 'i');\n    \n    for (const ns of namespaces) {\n      const memories = memoryStore.get(ns) || new Map();\n      cleanExpiredMemories(ns);\n      \n      for (const [key, memory] of memories.entries()) {\n        // Apply query search\n        const matchesQuery = queryRegex.test(key) || \n                           queryRegex.test(JSON.stringify(memory.value)) ||\n                           queryRegex.test(JSON.stringify(memory.tags));\n        \n        if (!matchesQuery) continue;\n        \n        // Apply filters\n        if (filters.tags && filters.tags.length > 0) {\n          const hasAllTags = filters.tags.every(tag => memory.tags.includes(tag));\n          if (!hasAllTags) continue;\n        }\n        \n        if (filters.createdAfter && new Date(memory.createdAt) < new Date(filters.createdAfter)) {\n          continue;\n        }\n        \n        if (filters.createdBefore && new Date(memory.createdAt) > new Date(filters.createdBefore)) {\n          continue;\n        }\n        \n        if (filters.minAccessCount && memory.accessCount < filters.minAccessCount) {\n          continue;\n        }\n        \n        results.push({\n          ...memory,\n          relevanceScore: calculateRelevance(memory, query)\n        });\n      }\n    }\n    \n    // Sort by relevance and limit\n    results.sort((a, b) => b.relevanceScore - a.relevanceScore);\n    \n    return {\n      success: true,\n      results: results.slice(0, limit),\n      totalFound: results.length\n    };\n  }\n});\n\n// Tool 4: Learning Capture\nexport const learningCaptureTool = createTool({\n  id: 'learning-capture',\n  name: 'Learning Capture',\n  description: 'Capture learning experiences',\n  version: '1.0.0',\n  inputSchema: z.object({\n    type: z.enum(['pattern', 'insight', 'correction', 'optimization', 'failure']),\n    context: z.string(),\n    input: z.any(),\n    output: z.any(),\n    outcome: z.enum(['success', 'failure', 'partial']),\n    confidence: z.number().min(0).max(1),\n    tags: z.array(z.string()).optional(),\n    relatedMemories: z.array(z.string()).optional()\n  }),\n  execute: async ({ type, context, input, output, outcome, confidence, tags, relatedMemories }) => {\n    const learningId = generateId();\n    const learning = {\n      id: learningId,\n      type,\n      context,\n      input,\n      output,\n      outcome,\n      confidence,\n      tags: tags || [],\n      relatedMemories: relatedMemories || [],\n      timestamp: new Date().toISOString(),\n      reinforcements: 0,\n      applications: 0\n    };\n    \n    learningStore.set(learningId, learning);\n    \n    // Store in memory for persistence\n    await memoryStoreTool.execute({\n      namespace: 'learning',\n      key: `learning_${learningId}`,\n      value: learning,\n      tags: ['learning', type, outcome, ...tags || []]\n    });\n    \n    // Update related memories\n    if (relatedMemories && relatedMemories.length > 0) {\n      for (const memoryKey of relatedMemories) {\n        const memory = await memoryRetrieveTool.execute({\n          namespace: 'default',\n          key: memoryKey\n        });\n        \n        if (memory.success && memory.memory) {\n          memory.memory.metadata.relatedLearnings = memory.memory.metadata.relatedLearnings || [];\n          memory.memory.metadata.relatedLearnings.push(learningId);\n        }\n      }\n    }\n    \n    return {\n      success: true,\n      learning: {\n        id: learningId,\n        type,\n        outcome,\n        confidence\n      }\n    };\n  }\n});\n\n// Tool 5: Pattern Recognize\nexport const patternRecognizeTool = createTool({\n  id: 'pattern-recognize',\n  name: 'Pattern Recognize',\n  description: 'Recognize patterns in data',\n  version: '1.0.0',\n  inputSchema: z.object({\n    data: z.array(z.any()),\n    patternTypes: z.array(z.enum(['sequence', 'frequency', 'correlation', 'anomaly'])).optional(),\n    threshold: z.number().min(0).max(1).default(0.7)\n  }),\n  execute: async ({ data, patternTypes = ['sequence', 'frequency'], threshold }) => {\n    const patterns = [];\n    \n    // Frequency analysis\n    if (patternTypes.includes('frequency')) {\n      const frequencyMap = new Map();\n      data.forEach(item => {\n        const key = JSON.stringify(item);\n        frequencyMap.set(key, (frequencyMap.get(key) || 0) + 1);\n      });\n      \n      for (const [item, count] of frequencyMap.entries()) {\n        const frequency = count / data.length;\n        if (frequency >= threshold) {\n          patterns.push({\n            type: 'frequency',\n            pattern: JSON.parse(item),\n            confidence: frequency,\n            occurrences: count\n          });\n        }\n      }\n    }\n    \n    // Sequence detection\n    if (patternTypes.includes('sequence') && data.length >= 2) {\n      const sequences = new Map();\n      for (let i = 0; i < data.length - 1; i++) {\n        for (let length = 2; length <= Math.min(5, data.length - i); length++) {\n          const seq = data.slice(i, i + length);\n          const key = JSON.stringify(seq);\n          sequences.set(key, (sequences.get(key) || 0) + 1);\n        }\n      }\n      \n      for (const [seq, count] of sequences.entries()) {\n        if (count >= 2) {\n          const confidence = count / (data.length - JSON.parse(seq).length + 1);\n          if (confidence >= threshold) {\n            patterns.push({\n              type: 'sequence',\n              pattern: JSON.parse(seq),\n              confidence,\n              occurrences: count\n            });\n          }\n        }\n      }\n    }\n    \n    // Anomaly detection\n    if (patternTypes.includes('anomaly')) {\n      const frequencies = new Map();\n      data.forEach(item => {\n        const key = JSON.stringify(item);\n        frequencies.set(key, (frequencies.get(key) || 0) + 1);\n      });\n      \n      const avgFrequency = data.length / frequencies.size;\n      for (const [item, count] of frequencies.entries()) {\n        const deviation = Math.abs(count - avgFrequency) / avgFrequency;\n        if (deviation > (1 - threshold)) {\n          patterns.push({\n            type: 'anomaly',\n            pattern: JSON.parse(item),\n            confidence: deviation,\n            occurrences: count,\n            expectedOccurrences: avgFrequency\n          });\n        }\n      }\n    }\n    \n    // Store recognized patterns\n    for (const pattern of patterns) {\n      await learningCaptureTool.execute({\n        type: 'pattern',\n        context: 'pattern_recognition',\n        input: data,\n        output: pattern,\n        outcome: 'success',\n        confidence: pattern.confidence,\n        tags: ['pattern', pattern.type]\n      });\n    }\n    \n    return {\n      success: true,\n      patterns: patterns.sort((a, b) => b.confidence - a.confidence),\n      totalPatternsFound: patterns.length\n    };\n  }\n});\n\n// Tool 6: Knowledge Graph\nexport const knowledgeGraphTool = createTool({\n  id: 'knowledge-graph',\n  name: 'Knowledge Graph',\n  description: 'Build and query knowledge graphs',\n  version: '1.0.0',\n  inputSchema: z.object({\n    action: z.enum(['add_node', 'add_edge', 'query', 'traverse', 'delete_node']),\n    nodeId: z.string().optional(),\n    nodeData: z.any().optional(),\n    sourceId: z.string().optional(),\n    targetId: z.string().optional(),\n    edgeType: z.string().optional(),\n    edgeData: z.any().optional(),\n    query: z.object({\n      type: z.enum(['node', 'edge', 'path', 'neighbors']).optional(),\n      filters: z.record(z.any()).optional(),\n      depth: z.number().optional()\n    }).optional()\n  }),\n  execute: async ({ action, nodeId, nodeData, sourceId, targetId, edgeType, edgeData, query }) => {\n    if (!knowledgeGraphStore.has('nodes')) {\n      knowledgeGraphStore.set('nodes', new Map());\n      knowledgeGraphStore.set('edges', new Map());\n    }\n    \n    const nodes = knowledgeGraphStore.get('nodes');\n    const edges = knowledgeGraphStore.get('edges');\n    \n    switch (action) {\n      case 'add_node': {\n        if (!nodeId) return { success: false, error: 'Node ID required' };\n        \n        const node = {\n          id: nodeId,\n          data: nodeData || {},\n          createdAt: new Date().toISOString(),\n          edges: { incoming: [], outgoing: [] }\n        };\n        \n        nodes.set(nodeId, node);\n        \n        return { success: true, node };\n      }\n      \n      case 'add_edge': {\n        if (!sourceId || !targetId || !edgeType) {\n          return { success: false, error: 'Source ID, target ID, and edge type required' };\n        }\n        \n        const edgeId = `${sourceId}-${edgeType}-${targetId}`;\n        const edge = {\n          id: edgeId,\n          source: sourceId,\n          target: targetId,\n          type: edgeType,\n          data: edgeData || {},\n          createdAt: new Date().toISOString()\n        };\n        \n        edges.set(edgeId, edge);\n        \n        // Update node connections\n        const sourceNode = nodes.get(sourceId);\n        const targetNode = nodes.get(targetId);\n        \n        if (sourceNode) {\n          sourceNode.edges.outgoing.push(edgeId);\n        }\n        if (targetNode) {\n          targetNode.edges.incoming.push(edgeId);\n        }\n        \n        return { success: true, edge };\n      }\n      \n      case 'query': {\n        if (!query) return { success: false, error: 'Query parameters required' };\n        \n        const results = [];\n        \n        if (query.type === 'node' || !query.type) {\n          for (const [id, node] of nodes.entries()) {\n            if (matchesFilters(node.data, query.filters)) {\n              results.push({ type: 'node', ...node });\n            }\n          }\n        }\n        \n        if (query.type === 'edge' || !query.type) {\n          for (const [id, edge] of edges.entries()) {\n            if (matchesFilters(edge.data, query.filters)) {\n              results.push({ type: 'edge', ...edge });\n            }\n          }\n        }\n        \n        if (query.type === 'neighbors' && nodeId) {\n          const node = nodes.get(nodeId);\n          if (node) {\n            const neighbors = new Set();\n            \n            // Get direct neighbors\n            node.edges.outgoing.forEach(edgeId => {\n              const edge = edges.get(edgeId);\n              if (edge) neighbors.add(edge.target);\n            });\n            \n            node.edges.incoming.forEach(edgeId => {\n              const edge = edges.get(edgeId);\n              if (edge) neighbors.add(edge.source);\n            });\n            \n            neighbors.forEach(neighborId => {\n              const neighborNode = nodes.get(neighborId);\n              if (neighborNode) {\n                results.push({ type: 'node', ...neighborNode });\n              }\n            });\n          }\n        }\n        \n        return { success: true, results };\n      }\n      \n      case 'traverse': {\n        if (!nodeId || !query) return { success: false, error: 'Node ID and query required' };\n        \n        const visited = new Set();\n        const path = [];\n        const maxDepth = query.depth || 3;\n        \n        function traverse(currentId, depth) {\n          if (depth > maxDepth || visited.has(currentId)) return;\n          \n          visited.add(currentId);\n          const node = nodes.get(currentId);\n          if (!node) return;\n          \n          path.push({ type: 'node', ...node });\n          \n          node.edges.outgoing.forEach(edgeId => {\n            const edge = edges.get(edgeId);\n            if (edge && (!query.filters || matchesFilters(edge.data, query.filters))) {\n              path.push({ type: 'edge', ...edge });\n              traverse(edge.target, depth + 1);\n            }\n          });\n        }\n        \n        traverse(nodeId, 0);\n        \n        return { success: true, path };\n      }\n      \n      case 'delete_node': {\n        if (!nodeId) return { success: false, error: 'Node ID required' };\n        \n        const node = nodes.get(nodeId);\n        if (!node) return { success: false, error: 'Node not found' };\n        \n        // Remove associated edges\n        [...node.edges.incoming, ...node.edges.outgoing].forEach(edgeId => {\n          edges.delete(edgeId);\n        });\n        \n        nodes.delete(nodeId);\n        \n        return { success: true, deleted: nodeId };\n      }\n      \n      default:\n        return { success: false, error: 'Invalid action' };\n    }\n  }\n});\n\n// Tool 7: Memory Backup\nexport const memoryBackupTool = createTool({\n  id: 'memory-backup',\n  name: 'Memory Backup',\n  description: 'Backup memory stores',\n  version: '1.0.0',\n  inputSchema: z.object({\n    namespaces: z.array(z.string()).optional(),\n    includeKnowledgeGraph: z.boolean().default(true),\n    includeLearning: z.boolean().default(true),\n    backupId: z.string().optional()\n  }),\n  execute: async ({ namespaces, includeKnowledgeGraph, includeLearning, backupId }) => {\n    const backup = {\n      id: backupId || generateId(),\n      timestamp: new Date().toISOString(),\n      memories: {},\n      knowledgeGraph: null,\n      learning: null,\n      metadata: {\n        totalMemories: 0,\n        totalNodes: 0,\n        totalEdges: 0,\n        totalLearnings: 0\n      }\n    };\n    \n    // Backup memories\n    const namespacesToBackup = namespaces || Array.from(memoryStore.keys());\n    for (const namespace of namespacesToBackup) {\n      const memories = memoryStore.get(namespace);\n      if (memories) {\n        backup.memories[namespace] = Array.from(memories.entries());\n        backup.metadata.totalMemories += memories.size;\n      }\n    }\n    \n    // Backup knowledge graph\n    if (includeKnowledgeGraph && knowledgeGraphStore.has('nodes')) {\n      backup.knowledgeGraph = {\n        nodes: Array.from(knowledgeGraphStore.get('nodes').entries()),\n        edges: Array.from(knowledgeGraphStore.get('edges').entries())\n      };\n      backup.metadata.totalNodes = backup.knowledgeGraph.nodes.length;\n      backup.metadata.totalEdges = backup.knowledgeGraph.edges.length;\n    }\n    \n    // Backup learning data\n    if (includeLearning) {\n      backup.learning = Array.from(learningStore.entries());\n      backup.metadata.totalLearnings = backup.learning.length;\n    }\n    \n    backupStore.set(backup.id, backup);\n    \n    return {\n      success: true,\n      backup: {\n        id: backup.id,\n        timestamp: backup.timestamp,\n        metadata: backup.metadata\n      }\n    };\n  }\n});\n\n// Tool 8: Memory Restore\nexport const memoryRestoreTool = createTool({\n  id: 'memory-restore',\n  name: 'Memory Restore',\n  description: 'Restore from backups',\n  version: '1.0.0',\n  inputSchema: z.object({\n    backupId: z.string(),\n    namespaces: z.array(z.string()).optional(),\n    restoreKnowledgeGraph: z.boolean().default(true),\n    restoreLearning: z.boolean().default(true),\n    merge: z.boolean().default(false)\n  }),\n  execute: async ({ backupId, namespaces, restoreKnowledgeGraph, restoreLearning, merge }) => {\n    const backup = backupStore.get(backupId);\n    if (!backup) {\n      return { success: false, error: 'Backup not found' };\n    }\n    \n    const restored = {\n      memories: 0,\n      nodes: 0,\n      edges: 0,\n      learnings: 0\n    };\n    \n    // Restore memories\n    const namespacesToRestore = namespaces || Object.keys(backup.memories);\n    for (const namespace of namespacesToRestore) {\n      if (backup.memories[namespace]) {\n        if (!merge) {\n          memoryStore.set(namespace, new Map());\n        }\n        \n        const memories = memoryStore.get(namespace) || new Map();\n        for (const [key, value] of backup.memories[namespace]) {\n          memories.set(key, value);\n          restored.memories++;\n        }\n        memoryStore.set(namespace, memories);\n      }\n    }\n    \n    // Restore knowledge graph\n    if (restoreKnowledgeGraph && backup.knowledgeGraph) {\n      if (!merge) {\n        knowledgeGraphStore.set('nodes', new Map());\n        knowledgeGraphStore.set('edges', new Map());\n      }\n      \n      const nodes = knowledgeGraphStore.get('nodes') || new Map();\n      const edges = knowledgeGraphStore.get('edges') || new Map();\n      \n      for (const [id, node] of backup.knowledgeGraph.nodes) {\n        nodes.set(id, node);\n        restored.nodes++;\n      }\n      \n      for (const [id, edge] of backup.knowledgeGraph.edges) {\n        edges.set(id, edge);\n        restored.edges++;\n      }\n      \n      knowledgeGraphStore.set('nodes', nodes);\n      knowledgeGraphStore.set('edges', edges);\n    }\n    \n    // Restore learning data\n    if (restoreLearning && backup.learning) {\n      if (!merge) {\n        learningStore.clear();\n      }\n      \n      for (const [id, learning] of backup.learning) {\n        learningStore.set(id, learning);\n        restored.learnings++;\n      }\n    }\n    \n    return {\n      success: true,\n      restored,\n      backup: {\n        id: backup.id,\n        timestamp: backup.timestamp\n      }\n    };\n  }\n});\n\n// Tool 9: Context Save\nexport const contextSaveTool = createTool({\n  id: 'context-save',\n  name: 'Context Save',\n  description: 'Save execution context',\n  version: '1.0.0',\n  inputSchema: z.object({\n    contextId: z.string().optional(),\n    state: z.any(),\n    activeMemories: z.array(z.string()).optional(),\n    activePatterns: z.array(z.string()).optional(),\n    metadata: z.record(z.any()).optional()\n  }),\n  execute: async ({ contextId, state, activeMemories, activePatterns, metadata }) => {\n    const id = contextId || generateId();\n    const context = {\n      id,\n      state,\n      activeMemories: activeMemories || [],\n      activePatterns: activePatterns || [],\n      metadata: metadata || {},\n      timestamp: new Date().toISOString(),\n      checkpoints: []\n    };\n    \n    // Create a snapshot of referenced memories\n    if (activeMemories && activeMemories.length > 0) {\n      context.memorySnapshots = {};\n      for (const memoryKey of activeMemories) {\n        const parts = memoryKey.split(':');\n        const namespace = parts.length > 1 ? parts[0] : 'default';\n        const key = parts.length > 1 ? parts[1] : memoryKey;\n        \n        const result = await memoryRetrieveTool.execute({ namespace, key });\n        if (result.success && result.memory) {\n          context.memorySnapshots[memoryKey] = result.memory;\n        }\n      }\n    }\n    \n    contextStore.set(id, context);\n    \n    // Also save to memory for persistence\n    await memoryStoreTool.execute({\n      namespace: 'contexts',\n      key: `context_${id}`,\n      value: context,\n      tags: ['context', 'snapshot']\n    });\n    \n    return {\n      success: true,\n      context: {\n        id,\n        timestamp: context.timestamp,\n        activeMemories: context.activeMemories.length,\n        stateSize: JSON.stringify(state).length\n      }\n    };\n  }\n});\n\n// Tool 10: Context Restore\nexport const contextRestoreTool = createTool({\n  id: 'context-restore',\n  name: 'Context Restore',\n  description: 'Restore execution context',\n  version: '1.0.0',\n  inputSchema: z.object({\n    contextId: z.string(),\n    restoreMemories: z.boolean().default(true),\n    checkpoint: z.number().optional()\n  }),\n  execute: async ({ contextId, restoreMemories, checkpoint }) => {\n    let context = contextStore.get(contextId);\n    \n    // Try to load from persistent memory if not in cache\n    if (!context) {\n      const result = await memoryRetrieveTool.execute({\n        namespace: 'contexts',\n        key: `context_${contextId}`\n      });\n      \n      if (result.success && result.memory) {\n        context = result.memory.value;\n        contextStore.set(contextId, context);\n      }\n    }\n    \n    if (!context) {\n      return { success: false, error: 'Context not found' };\n    }\n    \n    // Restore to specific checkpoint if requested\n    let targetState = context.state;\n    if (checkpoint !== undefined && context.checkpoints[checkpoint]) {\n      targetState = context.checkpoints[checkpoint].state;\n    }\n    \n    const restored = {\n      state: targetState,\n      activeMemories: context.activeMemories,\n      activePatterns: context.activePatterns,\n      metadata: context.metadata,\n      timestamp: context.timestamp\n    };\n    \n    // Restore memory references\n    if (restoreMemories && context.memorySnapshots) {\n      restored.memories = {};\n      for (const [key, snapshot] of Object.entries(context.memorySnapshots)) {\n        restored.memories[key] = snapshot;\n      }\n    }\n    \n    return {\n      success: true,\n      context: restored,\n      checkpointsAvailable: context.checkpoints.length\n    };\n  }\n});\n\n// Utility functions\nfunction calculateRelevance(memory, query) {\n  let score = 0;\n  const queryLower = query.toLowerCase();\n  \n  // Check key match\n  if (memory.key.toLowerCase().includes(queryLower)) {\n    score += 5;\n  }\n  \n  // Check value match\n  const valueStr = JSON.stringify(memory.value).toLowerCase();\n  if (valueStr.includes(queryLower)) {\n    score += 3;\n  }\n  \n  // Check tags match\n  memory.tags.forEach(tag => {\n    if (tag.toLowerCase().includes(queryLower)) {\n      score += 2;\n    }\n  });\n  \n  // Boost for recent access\n  const hoursSinceAccess = (Date.now() - new Date(memory.lastAccessed).getTime()) / (1000 * 60 * 60);\n  if (hoursSinceAccess < 24) {\n    score += 2;\n  } else if (hoursSinceAccess < 168) { // 1 week\n    score += 1;\n  }\n  \n  // Boost for high access count\n  if (memory.accessCount > 10) {\n    score += 1;\n  }\n  \n  return score;\n}\n\nfunction matchesFilters(data, filters) {\n  if (!filters) return true;\n  \n  for (const [key, value] of Object.entries(filters)) {\n    if (data[key] !== value) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n// Export all tools\n// export const learningMemoryTools = [\n//   memoryStoreTool,\n//   memoryRetrieveTool,\n//   memorySearchTool,\n//   learningCaptureTool,\n//   patternRecognizeTool,\n//   knowledgeGraphTool,\n//   memoryBackupTool,\n//   memoryRestoreTool,\n//   contextSaveTool,\n//   contextRestoreTool\n// ];\n// Export as object for consistency\nexport const learningMemoryTools = {\n  memoryStoreTool,\n  memoryRetrieveTool,\n  memorySearchTool,\n  learningCaptureTool,\n  patternRecognizeTool,\n  knowledgeGraphTool,\n  memoryBackupTool,\n  memoryRestoreTool,\n  contextSaveTool,\n  contextRestoreTool\n};\n"],"names":[],"mappings":"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"}